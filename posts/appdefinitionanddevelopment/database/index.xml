<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database on Will&#39;s Blog</title>
    <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/</link>
    <description>Recent content in Database on Will&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Mar 2022 21:00:10 +0800</lastBuildDate><atom:link href="https://travis103.github.io/posts/appdefinitionanddevelopment/database/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>Redisearch</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/redisearch/</link>
      <pubDate>Fri, 25 Mar 2022 15:06:13 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/redisearch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Elasticsearcch</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/elasticsearcch/</link>
      <pubDate>Fri, 25 Mar 2022 15:06:04 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/elasticsearcch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sqlite</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/sqlite/</link>
      <pubDate>Thu, 24 Mar 2022 10:38:46 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/sqlite/</guid>
      <description>Install Config Usage </description>
    </item>
    
    <item>
      <title>Memcached</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/memcached/</link>
      <pubDate>Thu, 24 Mar 2022 10:34:53 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/memcached/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/redis/</link>
      <pubDate>Thu, 24 Mar 2022 10:34:47 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/redis/</guid>
      <description>https://redis.io/commands
 NoSQL(Not Only SQL） NoSQL指的是非关系型数据库，是对不同于传统关系型数据库的数据库管理系统简称，NoSQL是web2.0时代海量数据催生的产物。
特点： 不支持SQL语法 NoSQL的世界中没有通用的语言，每种nosql数据库都有自己的语法，以及擅长的业务场景。 读写性能高 NoSQL数据库都具有非常高的读写性能，尤其在海量数据下，它的表现非常优秀。 灵活的数据模型 NoSQL的存储方式十分灵活，存储方式可以是JSON文档、键值对（key-value）或者其他方式。
redis 基本操作
 什么是Redis Redis是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server，该软件使用C语言编写，Redis是一个key-value存储系统，它支持丰富的数据类型，如：string、list、set、zset(sorted set)、hash。 redis是一种nosql数据库,他的数据是保存在内存中，同时redis可以定时把内存数据同步到磁盘，即可以将数据持久化，还提供了多个语言的API，操作比较方便 Redis特点: Redis以内存作为数据存储介质，所以读写数据的效率极高，远远超过数据库。 Redis应用场景: 因为Redis交换数据快，所以在服务器中常用来存储一些需要频繁调取的数据，这样可以大大节省系统直接读取磁盘来获得数据的I/O开销，更重要的是可以极大提升速度。 将这种热点数据存到Redis（内存）中，要用的时候，直接从内存取，极大的提高了速度和节约了服务器的开销。  关系型数据库和非关系数据库的区别 关系型数据库 表和表之间存在的关系 非关系型数据库 不存在表的这种概念,redis是键值对数据库，通过key查找value 所以key是唯一的。
redis五种数据类型、及操作 string 字符串 list 列表 hash 哈希 set 集合 sorted sets 有序集合
key 有5中数据类型：string、list、set、zset(sorted set)、hash。 value :都是字符串类型的(可加引号也可不加)
set key value get key ttl key expire key seconds set key value ex seconds setex key seconds value append key value</description>
    </item>
    
    <item>
      <title>Mongo</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/mongo/</link>
      <pubDate>Thu, 24 Mar 2022 10:34:39 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/mongo/</guid>
      <description>mongo bson BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON。MongoDB使用了BSON这种结构来存储数据和网络数据交换。 BSON对应Document这个概念，因为BSON是schema-free的，所以在MongoDB中所对应的Document也有这个特征，这里的一个Document也可以理解成关系数据库中的一条Record，只是Document的变化更丰富一些，Document可以嵌套。 MongoDB以BSON做为其存储结构的一个重要原因是它的可遍历性。 BSON编码扩展了JSON表示，使其包含额外的类型，如int、long、date、浮点数和decimal128。 BSON数据的主要类型有：A，D，E，M和Raw。其中，A是数组，D是切片，M是映射，D和M是Go原生类型。   A类型表示有序的BSON数组。 bson.A{&amp;ldquo;bar&amp;rdquo;, &amp;ldquo;world&amp;rdquo;, 3.14159, bson.D{{&amp;ldquo;qux&amp;rdquo;, 12345}}}
  D类型表示包含有序元素的BSON文档。这种类型应该在顺序重要的情况下使用。如果元素的顺序无关紧要，则应使用M代替。 bson.D{{&amp;ldquo;foo&amp;rdquo;, &amp;ldquo;bar&amp;rdquo;}, {&amp;ldquo;hello&amp;rdquo;, &amp;ldquo;world&amp;rdquo;}, {&amp;ldquo;pi&amp;rdquo;, 3.14159}}
  M类型表示无序的映射。 bson.M{&amp;ldquo;foo&amp;rdquo;: &amp;ldquo;bar&amp;rdquo;, &amp;ldquo;hello&amp;rdquo;: &amp;ldquo;world&amp;rdquo;, &amp;ldquo;pi&amp;rdquo;: 3.14159}
  E类型表示D里面的一个BSON元素。
  Raw类型代表未处理的原始BSON文档和元素，Raw系列类型用于验证和检索字节切片中的元素。当要查找BSON字节而不将其解编为另一种类型时，此类型最有用。
  mongo 10.1.50.84/pacific -u root -p Root_123 &amp;ndash;authenticationDatabase admin
rs.status() rs.slaveOk()
rs=replica set
db.getCollection(&amp;lsquo;demo&amp;rsquo;).find({&amp;ldquo;keyIdentifiers&amp;rdquo;:{&amp;quot;$regex&amp;quot;:&amp;quot;@#@&amp;quot;}}).forEach(function(item){ var keyIdentifiers = item.keyIdentifiers; var arr = keyIdentifiers[0].split(&amp;quot;@#@&amp;quot;); if(arr.length&amp;gt;1){ var item1 = arr[0] var item2 = arr[1] var tem = &amp;quot;&amp;quot; if(item1.</description>
    </item>
    
    <item>
      <title>Postgresql</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/postgresql/</link>
      <pubDate>Thu, 24 Mar 2022 10:34:31 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/postgresql/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://travis103.github.io/posts/appdefinitionanddevelopment/database/mysql/</link>
      <pubDate>Thu, 24 Mar 2022 10:34:23 +0800</pubDate>
      
      <guid>https://travis103.github.io/posts/appdefinitionanddevelopment/database/mysql/</guid>
      <description>from_unixtime(add_time/1000) as time
连接查询 内连接查询 内连接（join）：从左表取出一条记录，去和右表中所有记录进行匹配，相同的会保留下来。 基本语法：左表 join 右表 on 左表.字段 = 右表.字段
例： select a.id,a.name,a,sex,b.country,b.city,b.street from student a join addr b on a.addrid=b.addrid;
外连接查询 左连接（left join）：以左表为主表 基本语法：from 左表 left join 右表 on 左表.字段 = 右表.字段 例： select a.id,a.name,a.addrid,b.country,b.city from student a left join addr b on a.addrid=b.addrid;
右连接（right join）：以右表为主表 基本语法：from 左表 right join 右表 on 左表.字段 = 右表.字段； 例： select a.id,a.name,a.addrid,b.country,b.city from student a right join addr b on a.</description>
    </item>
    
    
  </channel>
</rss>
